export const golang = [
  {
    question: `What are race conditions in Go? How can you detect and prevent them?`,
    answer: `A race condition occurs when multiple goroutines access shared data concurrently, and at least one of them modifies it, leading to unpredictable results depending on the timing of operations.- Detection: Use Go's built-in race detector: go test -race or go run -race.- Prevention:  - Mutexes (sync.Mutex, sync.RWMutex): Protect shared data by allowing only one goroutine (or multiple readers for RWMutex) to access it at a time.  - Channels: Communicate data between goroutines instead of sharing memory. This often makes ownership clearer, aligning with Go's "Don't communicate by sharing memory; share memory by communicating" philosophy.  - Atomic operations (sync/atomic package): For simple counter or flag updates that require high performance.`,
  },
  {
    question: `Explain deadlocks in Go and how to avoid them.`,
    answer: `A deadlock occurs when two or more goroutines are blocked forever, each waiting for the other to release a resource. A classic example is two goroutines trying to acquire two locks in opposite orders.- Avoidance:  - Lock Ordering: Always acquire locks in a consistent, predefined order across all goroutines.  - Avoid Nested Locks: If possible, reduce the scope of locks and avoid holding multiple locks simultaneously.  - Use select with timeouts or default cases: For channel operations to prevent indefinite blocking if no communication partner is ready.  - Careful Design: Plan the interaction and resource access patterns of your concurrent components meticulously.`,
  },
  {
    question: `What are Go Modules?`,
    answer: `Go Modules are Go's official dependency management system, introduced in Go 1.11 and the default since Go 1.14. They allow projects to define their dependencies and specific versions independently of their location in GOPATH.- go.mod file: Defines the module path, the Go version, and the project's direct dependencies with their required versions.- go.sum file: Contains checksums of direct and indirect dependencies to ensure the integrity and authenticity of downloaded modules.- Commands: go mod init, go get, go mod tidy, go build, go test etc., all work within the context of a module.`,
  },
  {
    question: `Explain the difference between slice and array again, focusing on their underlying structure and behavior.`,
    answer: `An Array is a fixed-size sequence of elements of the same type. Its size is part of its type ([5]int is different from [10]int). Arrays are value types; when you pass an array to a function or assign it, a copy is made.A Slice is a dynamic-sized, flexible view into an underlying array. A slice is a struct (descriptor) containing three fields:1.  Pointer: Points to the first element of the accessible portion of the underlying array.2.  Length: The number of elements currently in the slice.3.  Capacity: The number of elements in the underlying array, starting from the slice's pointer, that are available for the slice to use.Slices are reference types in behavior (though technically a struct passed by value); changes made to the slice's elements modify the underlying array, affecting other slices that point to the same array. When a slice grows beyond its capacity using append, a new, larger underlying array is allocated, and the elements are copied to the new array. The slice's pointer is then updated to point to this new array.`,
  },
  {
    question: `How would you implement a simple worker pool in Go?`,
    answer: `A common way to implement a worker pool involves:1.  A channel for jobs: A buffered channel where tasks (jobs) are sent.2.  A channel for results: A channel where workers send back results (optional, but common).3.  Worker goroutines: A fixed number of goroutines that listen on the job channel, process tasks, and send results to the result channel.4.  A sync.WaitGroup: To wait for all worker goroutines to finish processing all jobs.The main goroutine sends jobs to the job channel, closes the job channel when all jobs are sent, and waits for the WaitGroup. Workers loop, receiving jobs from the job channel until it's closed, process the job, send results (if applicable), and call Done() on the WaitGroup.`,
  },
  {
    question: `Explain Go's garbage collection mechanism.`,
    answer: `Go uses a concurrent, tri-color mark-and-sweep garbage collector. It aims for low latency by performing most of the marking phase concurrently with the running program.- Tri-Color: Objects are conceptually colored white (unvisited), grey (visited, but its children haven't been scanned), or black (visited, and all its children have been scanned).- Mark Phase: The collector starts by marking root objects (globals, stack variables) as grey. It then traverses the object graph, moving grey objects to black and marking their children grey. This happens mostly concurrently.- Sweep Phase: After the mark phase, the collector iterates through the memory, reclaiming memory occupied by white objects (those not reachable from roots).- Pacing: The collector uses a "pacer" to decide when to run the next collection cycle, aiming to start when the heap size has grown by a certain factor since the last collection.`,
  },
  {
    question: `What is reflection in Go? When would you use it and what are its drawbacks?`,
    answer: `Reflection is the ability of a program to examine and modify its own structure and behavior at runtime. In Go, the reflect package provides this capability.- Use Cases: Common in libraries or frameworks that need to work with arbitrary types, such as JSON/XML encoding/decoding, ORMs, serialization libraries, testing utilities, or dependency injection.- Drawbacks:  - Performance: Reflection is significantly slower than direct access.  - Type Safety: Reflection bypasses Go's static type checking, making it easier to introduce runtime errors (panics).  - Complexity: Code using reflection is often more difficult to read, write, and maintain.It should be used judiciously when static typing isn't feasible or when building generic infrastructure.`,
  },
  {
    question: `How do you handle signals in Go?`,
    answer: `Go applications can handle operating system signals (like SIGINT for Ctrl+C, SIGTERM for graceful shutdown) using the os/signal package. You typically create a channel that receives os.Signal values and use signal.Notify to register which signals you want to receive on that channel. A goroutine can then block on this channel, waiting for a signal to trigger cleanup or shutdown procedures.`,
  },
  {
    question: `Explain the use of the iota identifier.`,
    answer: `iota is a predeclared identifier used in const declarations. It represents successive untyped integer constants. The first use of iota in a const declaration is 0, the second is 1, and so on. It resets to 0 for each new const block. It's commonly used to create enumerations or sets of related constant values.\`\`\`goconst (    C0 = iota // 0    C1        // 1    C2        // 2)const (    A = iota * 10 // 0 * 10 = 0    B             // 1 * 10 = 10    C             // 2 * 10 = 20)const (    // iota resets to 0 here    Flag1 = 1 << iota // 1 << 0 = 1    Flag2             // 1 << 1 = 2    Flag3             // 1 << 2 = 4)\`\`\``,
  },
  {
    question: `What is the go generate command?`,
    answer: `go generate is a command that scans Go source files for special comments (//go:generate command args) and runs the specified commands. It's a flexible tool used for automating tasks like:- Generating code (e.g., String() methods using stringer).- Generating mocks (go install github.com/vektra/mockery/...@latest).- Generating parser or lexer code.- Embedding assets into executables.It helps keep generated code in sync with the source code it's derived from.`,
  },
  {
    question: `How do you embed dependencies or assets into a Go binary?`,
    answer: `Since Go 1.16, the standard library provides the embed package for embedding files and file trees into a Go binary. You can use directives like //go:embed filename.txt or //go:embed folder/* followed by a variable declaration (string, []byte, or fs.FS). This makes your binary self-contained and simplifies deployment.Before Go 1.16, third-party tools like go-bindata or packr were commonly used.`,
  },
  {
    question: `Describe the difference between sync.Map and a regular map with a sync.Mutex.`,
    answer: `- Regular map with sync.Mutex: Requires explicitly locking and unlocking the mutex around every read and write operation. This is straightforward but can be inefficient for highly concurrent access patterns, especially if reads are frequent, as every read requires exclusive lock acquisition.- sync.Map: Designed for concurrently accessed maps where keys are only written once and read many times (e.g., caches). It uses a more complex internal structure with a read-mostly map and a mutable map, employing atomic operations and mutexes internally. It aims to provide better performance for specific read-heavy concurrent scenarios compared to a simple map guarded by a single mutex.Choose sync.Map when your use case matches its design (concurrent, read-heavy, keys written infrequently). For general-purpose concurrent map access, a regular map with a sync.RWMutex or sync.Mutex is often simpler and sufficient, or even faster depending on the access pattern.`,
  },
  {
    question: `What is the role of the net/context (now context) package?`,
    answer: `The context package (context was moved from golang.org/x/net/context to the standard library in Go 1.7) is used to carry request-scoped values, cancellation signals, and deadlines across API boundaries, typically between goroutines in concurrent programs (like handling incoming requests in a server).It allows you to build cancelable and timeout-aware operations, ensuring that resources are released and goroutines are stopped when they are no longer needed (e.g., when a client disconnects or a request times out). Functions that need context-awareness should accept a context.Context as their first argument.`,
  },
  {
    question: `How would you implement a graceful shutdown of an HTTP server in Go?`,
    answer: `Graceful shutdown allows an HTTP server to stop accepting new connections but continue serving existing ones until they complete, preventing abrupt interruption of ongoing requests.1.  Listen for Signals: Use os/signal to listen for termination signals (SIGINT, SIGTERM).2.  Create a context.Context: Use context.WithCancel or context.WithTimeout.3.  Start Server in Goroutine: Run http.Server.ListenAndServe or ListenAndServeTLS in a separate goroutine.4.  Block on Signal Channel: The main goroutine blocks until a signal is received.5.  Call Shutdown(): When a signal is received, call http.Server.Shutdown(ctx). The Shutdown method stops the server from accepting new connections, closes idle connections, and waits for active connections to finish (respecting the context's deadline/cancellation).6.  Wait for Server Goroutine: Use sync.WaitGroup or listen on a channel to know when the server's ListenAndServe goroutine exits (it returns http.ErrServerClosed after Shutdown is called).`,
  },
  {
    question: `What are generics in Go (introduced in Go 1.18)?`,
    answer: `Generics allow you to write functions and types that work with multiple types without requiring the use of the empty interface (interface{}) and reflection. They enable code reuse while maintaining type safety.You define type parameters in square brackets [] after the function name or type name. These type parameters can have constraints (comparable, any, or custom interfaces) that specify which types are allowed to be used as arguments for the type parameter.Example:\`\`\`gofunc Map[T, U any](s []T, f func(T) U) []U {    result := make([]U, len(s))    for i, v := range s {        result[i] = f(v)    }    return result}\`\`\`Here, T and U are type parameters. any is a constraint meaning any type is allowed.`,
  },
  {
    question: `How do you perform profiling in Go?`,
    answer: `Go has excellent built-in profiling tools via the pprof package (runtime/pprof and net/http/pprof).1.  For Web Servers: Import net/http/pprof. This registers handlers at /debug/pprof which provide CPU, heap, goroutine, block, and mutex profiles.2.  For Command-Line Apps/Batch Jobs: Use runtime/pprof to manually start and stop CPU profiling (pprof.StartCPUProfile, pprof.StopCPUProfile) or write heap profiles (pprof.WriteHeapProfile).3.  Analyze Profiles: Use the go tool pprof command with the profile data (either the file or the URL for web servers) to analyze performance, view call graphs, flame graphs, etc.`,
  },
  {
    question: `Describe the concept of 'escaping' in Go.`,
    answer: `Escape analysis is a compiler optimization. It determines whether a variable allocated on the stack "escapes" to the heap. If a variable's lifetime is longer than the function it's declared in, or if it's accessed by multiple goroutines, it must be allocated on the heap; otherwise, it can be allocated on the stack.- Stack Allocation: Faster, memory is automatically reclaimed when the function returns, less pressure on the garbage collector.- Heap Allocation: Slower (requires GC), used for variables that need to persist beyond the function call or are shared across goroutines.Go's compiler performs escape analysis automatically. You can see the results using go build -gcflags='-m'.`,
  },
  {
    question: `When might you use the unsafe package?`,
    answer: `The unsafe package allows operations that bypass Go's type safety and memory safety guarantees, such as pointer arithmetic and converting between arbitrary types and pointers.- Use Cases: Interfacing with C code (cgo), performance-critical operations where type-safe Go code is too slow, low-level system programming, working with memory-mapped files, or implementing data structures with specific memory layouts.- Drawbacks: Code using unsafe is not guaranteed to be portable, can introduce memory bugs (like use-after-free), breaks type safety, and might be brittle across different Go versions or architectures.It should be used only when absolutely necessary and with extreme caution.`,
  },
  {
    question: `Explain method sets in Go.`,
    answer: `A method set is the collection of methods associated with a type. It determines which interfaces a type implements.- For a value type T: The method set consists of all methods declared with a value receiver (func (t T) Method()).- For a pointer type *T: The method set consists of all methods declared with either a value receiver (func (t T) Method()) or a pointer receiver (func (t *T) Method()).This means that if you have a value v of type T, you can only call methods with a value receiver. If you have a pointer p of type *T, you can call methods with both value and pointer receivers (the compiler will handle taking the address or dereferencing). An interface variable i can hold a value of type T only if the method set of T is a superset of the interface's methods. It can hold a value of type *T only if the method set of *T is a superset of the interface's methods.`,
  },
  {
    question: `How does cgo work?`,
    answer: `cgo is the mechanism that allows Go programs to call C code and C code to call Go code. It processes special comments in Go source files (import "C") that contain C code (declarations, functions, types).- Calling C from Go: cgo generates Go code that acts as a bridge to the C functions/types defined in the comments or included headers. This involves type conversions between Go and C representations.- Calling Go from C: You can export Go functions using //export FunctionName comments, and cgo will generate C-callable wrapper functions.cgo adds overhead due to the need to switch between the Go runtime stack and the C stack, type conversions, and potential synchronization issues. It also results in larger binaries and disables some Go toolchain features like cross-compilation to environments without a C compiler.`,
  },
  {
    question: `What are Go Fuzzing tests?`,
    answer: `Fuzzing is an automated testing technique that feeds unexpected, malformed, or random data as inputs to a program to discover bugs like crashes, panics, or security vulnerabilities.Go introduced native fuzzing support in Go 1.18 (go test -fuzz=FuzzTargetName). You write a fuzzing function starting with FuzzXxx that takes a *testing.F argument. The fuzzing engine repeatedly calls this function with new inputs derived from a corpus of seed inputs and newly generated inputs. The engine tries to generate inputs that increase code coverage or trigger interesting behavior.`,
  },
  {
    question: `Explain the difference between panic and error.`,
    answer: `- error: Represents anticipated or expected failures that are part of a function's normal control flow. Functions return an error value (often nil for success) to signal a problem. Callers are expected to check for and handle these errors explicitly.- panic: Indicates truly exceptional, unexpected, and often unrecoverable runtime errors (like accessing an index out of bounds, nil pointer dereference, or intentional panic() calls for critical failures). A panic stops the normal execution flow, unwinds the stack, and runs deferred functions. If not recovered (using recover() in a deferred function), it crashes the program.Errors are for expected problems you should handle; panics are for unexpected, catastrophic failures that usually indicate a programming bug or an unrecoverable system state.`,
  },
  {
    question: `What is a Goroutine Leak? How can you cause or prevent one?`,
    answer: `A goroutine leak occurs when a goroutine is started but never finishes execution, often because it's blocked indefinitely waiting for a resource (like a channel operation or a lock) that will never become available.- Causes:  - Sending to a channel that no one is receiving from.  - Receiving from a channel that no one is sending to.  - Blocking on a mutex that is never unlocked.  - Waiting on a sync.WaitGroup where Done() is not called the correct number of times.- Prevention:  - Use select with timeouts or default cases: Prevent indefinite blocking on channels.  - Ensure channels are closed: Signal to receivers that no more data is coming.  - Use context with cancellation/deadlines: Propagate cancellation signals to goroutines so they can exit gracefully.  - Careful Channel Design: Ensure every send has a potential receiver and vice-versa, or use buffered channels appropriately.  - Profile: Use go tool pprof with the goroutine profile (/debug/pprof/goroutine) to inspect running goroutines and identify blocked ones.`,
  },
  {
    question: `How do you manage configuration in a Go application?`,
    answer: `Common strategies for managing configuration include:- Environment Variables: Standard practice, especially for cloud-native applications (12-factor app). Simple and widely supported.- Configuration Files: Using formats like JSON, YAML, TOML, or .env. Libraries like viper, koanf, or simple encoding/json/gopkg.in/yaml.v2 can parse these.- Command-Line Flags: Using the flag package or third-party libraries like cobra or urfave/cli.- Configuration Services: Using external services like Consul, etcd, ZooKeeper, or cloud-specific configuration managers.Often, a combination is used, with environment variables or flags overriding values from config files.`,
  },
  {
    question: `What is the difference between concurrency and parallelism again?`,
    answer: `- Concurrency: The ability to deal with multiple things at once. It's a way of structuring a program as independently executing components (like goroutines) that can be interleaved on a single processor or run simultaneously on multiple processors. Focuses on structure and composition.- Parallelism: The ability to do multiple things at the same time. It's about the execution of multiple computations simultaneously, requiring multiple processing units (cores). Focuses on execution and throughput.A concurrent program may or may not run in parallel, depending on the available hardware and the Go runtime's scheduler. A parallel program is inherently concurrent in its structure (multiple parts running at once).`,
  },
  {
    question: `Explain the concept of 'channels are first-class citizens' in Go.`,
    answer: `This means channels are not merely compiler primitives but can be treated like any other value in Go. They can be:- Assigned to variables.- Passed as arguments to functions.- Returned from functions.- Stored in data structures (slices, maps, structs).- Sent and received on other channels.This capability makes channels incredibly flexible for designing complex concurrent communication and synchronization patterns.`,
  },
  {
    question: `How does the Go scheduler work?`,
    answer: `The Go scheduler uses a M:P:G model:- M (Machine): An OS thread.- P (Processor): A logical processor provided by the scheduler, which needs to be associated with an M to execute Goroutines.- G (Goroutine): A goroutine, representing a concurrent function execution.The scheduler multiplexes Gs onto Ps, and Ps are executed by Ms. When a goroutine blocks on a system call (like I/O), its M is blocked, but its P is handed off to another M, allowing other goroutines associated with that P to continue running. If a goroutine blocks on a channel or mutex, the scheduler can deschedule it and run another goroutine on the same P. This cooperative scheduling for Go's internal blocking points (channels, mutexes) combined with the hand-off mechanism for syscall blocking allows the scheduler to keep OS threads busy and efficiently manage a large number of goroutines.`,
  },
  {
    question: `What are Go plugins? What are their limitations?`,
    answer: `Go plugins (using the plugin package) allow you to build a Go program that can load and link code (plugins) at runtime. Plugins must be built specifically with the plugin build mode (go build -buildmode=plugin).- Use Cases: Implementing dynamic loading of modules, implementing plugin architectures, or providing extensibility for applications.- Limitations:  - Platform Support: Primarily works on Linux and macOS (less stable/supported on Windows).  - Go Version Compatibility: The plugin and the main program must be built with the exact same Go compiler version.  - Dependency Conflicts: Can be tricky if the plugin and main program have conflicting dependencies or versions.  - Type Identity: Types in the plugin are distinct from types in the main program, even if they have the same name and structure (unless passed via interfaces or serialized/deserialized).`,
  },
  {
    question: `Explain Tail Call Optimization (TCO) in Go.`,
    answer: `Go's compiler does not guarantee Tail Call Optimization (TCO). TCO is a compiler optimization where a function call at the very end of another function (a tail call) can sometimes be executed without allocating a new stack frame, potentially preventing stack overflow errors in deeply recursive functions.Because Go's scheduler manages goroutine stacks, which can grow and shrink, and because of the need to integrate with C code and support features like reflection and garbage collection stack scanning, implementing a general-purpose TCO is complex and not prioritized. Deep recursion is generally discouraged in favor of iterative solutions or explicit stack management if necessary.`,
  },
  {
    question: `How would you design a simple in-memory cache with expiration in Go?`,
    answer: `A simple design could involve:1.  A map[string]CacheItem: To store the cached data, where CacheItem is a struct containing the value and an expiration timestamp.2.  A sync.RWMutex: To protect the map for concurrent access.3.  Expiration Timestamp: Each CacheItem stores time.Time indicating when it expires.4.  Get Operation: Acquire read lock, check if key exists, check if item is expired. If expired, acquire write lock (or upgrade lock if RWMutex supports it, Go's doesn't), delete item, release lock, return not found. Otherwise, release read lock, return value.5.  Set Operation: Acquire write lock, store or update the item with value and expiration. Release write lock.6.  Cleanup Goroutine: A separate goroutine that periodically (e.g., every minute) acquires a write lock, iterates through the map, and deletes expired items. This prevents the cache from growing indefinitely with stale data. Alternatively, cleanup can happen lazily during Get/Set operations.`,
  },
];
